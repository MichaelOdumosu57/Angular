

template
90° 90°

45° are tips


90° update yr angular project90°
https://medium.com/panya-studio-engineering/angular-cli-update-issues-manually-update-your-angular-project-ba0b1ea1c727

90° Learning Angular 90°

to set up a reverse proxy look at the location /a in that default.conf file its real easy all you need really is the proxy pass
also you need https://medium.com/@icanhazstring/how-to-properly-get-angular-and-nginx-working-together-for-development-3e5d158734bf
so it can rebuild properly

for a free angular host
https://stackblitz.com/




90° Getting Started 90°

run
ng new my-app
accept defaults with accept and return key

cd my-app
ng serve
--open opens the app in your defualt browser
its running

180° editing components 180°
in src/app/app.component.ts
change title to My First Angular App

the css is like regular HTML programming added it to apply  a style


90° Tour of Heroes 90°

270°Angular is made of Components there are modular versios of React but simpler
    the class file is the .ts
    the template file is the .html

270°  replace this with anything you want
      <h1>{{title}}</h1>
      it related to the class file
      so the template puts on the class file like clothes

270°
    src/ is like a global that all components must use
    especially in src styles

270°
    to make a new component
    ng generate component [name of component]
    
360°
    @Component is a decorator function
        selector - the component's CSS element selector
        templateUrl— the location of the component's template file.
        styleUrls— the location of the component's private CSS styles.
        ngOnInit  is a lifecycle hook
        always export the component class
        
270°
    to add a a value for non app
    {{[value]}} with no
    this put between HTML tags is known as interpolation binding
    
270°
    to display a component add it to template for the AppComponet
    insert it
    <h1>{{title}}</h1>
    <app-heroes></app-heroes>

270°
    now we create a hero class
    youre basically importing a class in the example

270°
    now to properly show it
    <h2>{{hero.name | uppercase}} Details</h2>
    <div><span>id: </span>{{hero.id}}</div>
    <div><span>name: </span>{{hero.name}}</div>
    
    which lives in <app-heroes></app-heroes> amazing
    
270°
    users can edit it
    <input [(ngModel)]="hero.name" placeholder="name"/>
    where ngModel binds that
    
180°
    AppModule
    not everything is availbe by default
    this is in app.module.ts and they come as @NgModule decorators
    so you import it in app.module.ts
    import { FormsModule } from '@angular/forms';
    and you add it to the @NgModule decorrator, imports array
    
270°
    every component must be declared in exactly on NgModule declaration
    file:/app/app.module.ts
    
180°
<!--4-->
    A list of Heroes
    this is where typescript is noticeable
    
    files
    /src/app/mock-heroes.ts
    /src/app/heroes/heroes.component.ts
    
    to list use *ngFor
    /src/app/heroes.component.html
    
    never forget the asterick

270°
    event binding
<!--5-->
    files: /heroes.component.ts
        :heroes.component.html
    <li *ngFor="let hero of heroes" (click)="onSelect(hero)">
    

270°
<!--6-->
    however selectedHero does not exist
    use *ngIf to save the app
    files:heroes.component.html
    

270°
    <!--7-->
    stlying specific components in its list
    this is done with class binding
    [class.[className]]="hero === selectedHero"
    files:heroes.component.html
        
180°
    <!--8-->
    you want larger apps to maintain smaller ones
    so there are different component we have differnt ways to attach things
    property biding is present in the subComponent and the @Input decorator is needed to function properly
    files
    files:hero-detail.component.ts
        :hero-detail.component.html
        :heroes.component.html
        

180°
    <!--9-->
    you want services
        they rely on this dependecy injection system
    to do this
    ng generate service hero
    files:hero.service.ts
    files:hero.service.spec.ts
    
    it has a @Injectable decorator
    
270°
    <!--9-->
    this hero service component can grab data from anywhere
    
    you must make this availble to the dependecy injection system (DIS) by regeristing a provider
    provider creates or delivers a services
    HeroService must be registered as the provider of the service you set up an injector which is repsoible for putting
    the service in the right place
    in the Injectable decorator when its provided in the root it can remove it if its not needed
    
270°
    <!--10-->
    instrsting things happen a singleton instance
    now a service is running in your app
    file:heroes.component.ts
    
270°
    <!--11-->
    call the service
    is should be called in ngOnInit not in the constructor, the constructor shouldnt do anything
    so services need to be injected and special care must be taken
    
180°
     <!--12-->
    the service operates sync, but in a real world app we need this done in async, you can use a callback Promise or an Observable
    they are from the RxJS library
    fn returns an Observable<Hero[]> that emits a single value, the array of mock heroes.
    Observable.suscribe() is the async solution here
    files: hero.service.ts
           heroes.component.ts

180°
    <!--13-->
    Showing messages
    bascially executes that the service went through properly
    files:app.component.html
        /src/app/message.service.ts
        /src/app/messages/messages.component.ts
           
    
180°
    <!--14-->
    App routing
    in Angular, the best practice is to load and configure the router in a separate, top-level module that is dedicated to routing and imported by the root AppModule.
--flat puts the file in src/app instead of its own folder.
--module=app tells the CLI to register it in the imports array of the AppModule.
    files: /src/app/app-routing.module.ts
    
270°
    <!--15-->
    Routes
        when you navigate to localhost:4200/heroes you get the HeroesComponent its the same with  nginx routing
        You first must initialize the router and start it listening for browser location changes.
        I removes the Heroes-Component because you only want it when the user navigates to it
        you can make things work by moving codeblocks around
    files:app-routing.module.ts
        files:/src/app/app.component.html
        

180°
    <!--16-->
    Navigation
    add a nav and anchor element
    file:/src/app/app.component.html
    
180°
    <!--17-->
    Add a dashboard
    ng generate component dashboard
    folder /src/app/dashboard
        /src/app/app-routing.module.ts
    
270°
    <!--18-->
    Add a default route
    files: /src/app/app-routing.module.ts
            /src/app/app.component.html
                
270°
    <!--19-->
    add a hero detail route that hides that hero list from the heroes compoinet
    use : for routing parameters
    using interpolation binding to properly connect things
    tie the Heroes Component and Details Component together
    files:/src/app/app-routing.module.ts
        /src/app/dashbord/dashbord.component.html
        
270°
    <!--20-->
    Routable HeroDetailComponent
    now heroe detail needs a way to grab that from the routing and ask the service from HeroService and grab the data it needs from the server
    ActivatedRoute has info about the route
    files:/src/app/hero-detail/hero-detail.component.ts
    
270°
    <!--21-->
    if you go back in the browser you can move around in the app
    files:/src/app/hero-detail/hero-detail.component.ts
          /src/app/hero-detail/hero-detail.component.html
          
180°
    <!--22-->
    using Angular's HttpClient.
    communciate with remote server over http
    for express try to send what the ts fnd demands
        An observable from HttpClient always emits a single value AND thats it
        it can doe it mulitple times however
    HttpClient.get returns the body of the response as an untyped JSON object by default.
    file:/src/app/app.module.ts
    /AngularBackend/template_app.js
    
270°
    <!--23-->
    Error handling
    pipe result through RxJS catchError() operator.
    you can do what you want there
    file:/src/app/hero.service.ts
    
270°
    <!--24-->
    Tap into the observable
    passes them along to whoever needs it
    you can also go ahead and save it tell your backend to do this
    The HttpClient.put() method takes three parameters
    
        the URL
        the data to update (the modified hero in this case)
        options - consist of the header to send in the request
    

    file:/src/app/hero.service.ts
        /src/app/hero-detail.component.html
        /src/app/hero-detail.component.ts
        /AngularBackend/template_app.js
        /src/app/heroes.component.html
        /src/app/heroes.component.ts
    
270°
    <!--25-->
    so add the button to do it
    
    file: /src/app/heroes.component.html
          /src/app/heroes.component.ts
          /src/hero.service.ts
          /template_app.js
          
270°
    <!--26-->
    lets delete heroes
    
        files:/src/app/heroes.component.html
          /src/app/heroes.component.ts
          /src/hero.service.ts
          /template_app.js
          
270°
    <!--27-->
    a search of services
    ng generate component hero-search
    files:hero.service.ts
        dashboard.component.html
        hero-search.component.html
        
270°
    <!--28-->
    // <li *ngFor="let hero of heroes$ | async"" |" >
    $ shows heroes is an Observable
    seems like you have to declare it in its class file
    the async suscribes so you dont have to try
        files: hero-search.component.html
                 hero-search.component.ts
                 
270°
    <!--29-->
    A Subject is both a source of observable values and an Observable itself.
    you can suscribe
    you can push values using next method
    this is useful for something
    file:hero-detail.component




90°
    Lifecycle Hooks

    the pseudo summary of the life cycle hook
    Angular creates it, renders it, creates and renders its children, checks it when its data-bound properties change, and destroys it before removing it from the DOM. the lifecycle hooks give u access to the data at these events


180°
    LifeCycle Sequence
    
    ngOnChanges() receives a SimpleChanges Object
        Called before ngOnInit() and whenever one or more data-bound input properties change.
        
    ngOnInit() the DOM knows about the component
    
    ngDoCheck() Detect and act upon changes that Angular can't or won't detect on its own. called during every change detection run immediately after ngOnChanges()
    
    ngAfterContentInit() - called after first ngDoCheck(), after the content made all needed XHR
    
    ngAfterContentChecked() - called after Angular checks the component XHR results, made after every ngDoCheck
    
    ngAfterViewInit() - after angular makes views for component and its children
    
    ngAfterViewChecked() - after angular checks the compoent views
    
    ngOnDestroy() - Cleanup just before Angular destroys the directive/component. Unsubscribe Observables and detach event handlers to avoid memory leaks. called just before angular destory the directive component
    
360°

    Other Angular lifecycle hooks (they are in 3rd party libraries)
   
180°

    Lifecycle Examples
    
    keep logic in hooks as lean as possible they fire often
    
180°
    Spying OnInit and OnDestroy

  @Directive({selector: '[mySpy]'})
export class SpyDirective implements OnInit, OnDestroy {

  constructor(private logger: LoggerService) { }

  ngOnInit()    { this.logIt(`onInit`); }

  ngOnDestroy() { this.logIt(`onDestroy`); }

  private logIt(msg: string) {
    this.logger.log(`Spy #${nextId++} ${msg}`);
  }
}

by doing this  you can initalize and destory compoents the  same time the happen to elements


270°
    use ngOnInit for 2 main reasons
    
    to setup complex inits
    to setup the component after augular takes care of input,
    
    avoid doing this in the constructor
    
    ngOnChanges() is first chance to access  directive's data-bound input properties
    
270°
    OnDestroy()
    can tell your app a component is disappearing, unsuscribe from DOM events, stop interval timers, unregister all callbacks
    unregister all callbacks
    
270°
    OnChanges()
    is triggerd whenever it detects changes to its input properties of the component or directive
    
    on changes component

@Input() hero: Hero;
@Input() power: string;
    
ngOnChanges(changes: SimpleChanges) {
  for (let propName in changes) {
    let chng = changes[propName];
    let cur  = JSON.stringify(chng.currentValue);
    let prev = JSON.stringify(chng.previousValue);
    this.changeLog.push(`${propName}: currentValue = ${cur}, previousValue = ${prev}`);
  }
}


html
<on-changes [hero]="hero" [power]="power"></on-changes>

onChanges does not work with objects well becuase its look for a change in the refenece to the object keep this in mind

270°
    DoCheck()
    detect and act on changes angular does not deal with
    called several times watch out
    
    
    
180°
    AfterView

270°
    AfterViewInit()   ngAfterViewChecked()
    you can grant access access child compoenets like this

 @ViewChild(ChildViewComponent, {static: false}) viewChild: ChildViewComponent;

and work with them in those lifecycle hooks


thers an impt unidirectional data flow
 LoggerService.tick_then() postpones the log update for one turn of the browser's JavaScript cycle 

this needs to happen because a view cannot update at the same time it was composed, you need in this case 1 cycle of the event
loop for things to be ok or else Angular throws an error



180°
    AfterContent
    about  AfterContentInit()  and AfterContentChecked()

270°
    Content projection
    takes outside HTML content and brings it into the component (for AngularJS,this is know as transclusion)

    Never put content between a component's element tags unless you intend to project that content into the component.
  

so here

 `
  <div>-- projected content begins --</div>
    <ng-content></ng-content>
  <div>-- projected content ends --</div>`

child apps get attached to ng-content

270°
    AfterContent hooks

    the diffrence between  AfterContent and  AfterView    
    after view looks at children explicitly nested in the component
    afterContent looks at the children angular projected into the component
    
    ex
    
    export class AfterContentComponent implements AfterContentChecked, AfterContentInit {
      private prevHero = '';
      comment = '';
    
      // Query for a CONTENT child of type `ChildComponent`
      @ContentChild(ChildComponent, {static: false}) contentChild: ChildComponent;
    
      ngAfterContentInit() {
        // contentChild is set after the content has been initialized
        this.logIt('AfterContentInit');
        this.doSomething();
      }
    
      ngAfterContentChecked() {
        // contentChild is updated after the content has been checked
        if (this.prevHero === this.contentChild.hero) {
          this.logIt('AfterContentChecked (no change)');
        } else {
          this.prevHero = this.contentChild.hero;
          this.logIt('AfterContentChecked');
          this.doSomething();
        }
      }
      // ...
    }


180°
      there are no unidirectional flow worries with AfterContent



90°
    Template Syntax


180°
    HTML in templates

    Angular uses everything except for <script> tags, they are not javascript
    no point for <html>, <body>, and <base> 
    u extend yr HTML with component directive
    
180°
    Interpolation and Template Expressions
    
        
270°
    Interpolation {{...}}
    valid examples

    <h3>Current customer: {{ currentCustomer }}</h3>

    <div><img src="{{itemImageUrl}}"></div>


    <p>The sum of 1 + 1 is {{1 + 1}}.</p>  // the 1+1 is a template expression


    <p>The sum of 1 + 1 is not {{1 + 1 + getVal()}}.</p>

    angular evals the ... in {{}} converts to strings and concatenates to an element or directive property

    

45°
    If you'd like to use something other than {{ and }}, you can configure the interpolation delimiter via the interpolation option in the Component metadata.

270°
    Template expressions

    they are evel expr in {{}}, that must appear to the right of the = in property binding
    
    template syntax is like js however you cannot
  
        Assignments (=, +=, -=, ...)
        Operators such as new, typeof, instanceof, etc.
        Chaining expressions with ; or ,
        The increment and decrement operators ++ and --
        Some of the ES2015+ operators

    also
        No support for the bitwise operators such as | and &
        New template expression operators, such as |, ?. and

270°
    Expression context
    
    anohter form of interpolation binding

    <img [src]="itemImageUrl2">



    <li *ngFor="let customer of customers">{{customer.name}}</li>

    a template reference variable #customerInput
    <input #customerInput>{{customerInput.value}}

    try to only have 1 expression context however
  

360°
    Expression guidelines
    
    Simplicity
        leave all logic in the ts
    
    Quick execution
        Angular executes template expressions after every change detection cycle, aka async work
        to to cache results for expensive operations

    No visible side effects
        an expression or binding should only affect what is meant not anything else


270°
    Template statements
    <button (click)="deleteHero()">Delete hero</button>


    its like js where you can chain expression with ; and , but u cant
        new
        increment and decrement operators, ++ and --
        operator assignment, such as += and -=
        the bitwise operators | and &
        the template expression operators

360°
    Statement context
    its the component instance its the data that template statements have access to

    you also have access to
    
    the event object, *ngFor looping, and the var identifying the element itself

    <button (click)="onSave($event)">Save</button>
    <button *ngFor="let hero o f heroes" (click)="deleteHero(hero)">{{hero.name}}</button>
    <form #heroForm (ngSubmit)="onSubmit(heroForm)"> ... </form>


360°
    Statement guidelines
    cant access global objects, dont do complex logic there


270°
    Binding Syntax an Overview
    3 categories


    From the source-to-view
    From view-to-source
    Two-way sequence: view-to-source-to-view
    
    go copy the list
    

360°
    Data-binding and HTML
  <!-- Bind button disabled state to `isUnchanged` property -->
  <button [disabled]="isUnchanged">Save</button>
              

  works with properties of DOM elements, components, and directives not HTML attributes


360°
    HTML attribute vs. DOM property

    A few HTML attributes have 1:1 mapping to properties; for example, id.
    Some HTML attributes don't have corresponding properties; for example, aria-*.
    Some DOM properties don't have corresponding attributes; for example, textContent.  


    so attr are are to initalize DOM elements, HTML properties are subject to change


45°
    the only way to change attrs is with setAtttribute(), this also reinits corresponding DOM properites
    look here to see differences https://developer.mozilla.org/en-US/docs/Web/API#Interfaces


450°
    an <input>
    
    so for value = Sarah, the HTML attribute renmains unchanged if you inspect the attribute with

    input.getAttribute('value'), Sarah 

    to get the DOM property u just grab it, so you see to get HTML attributes u needa special fn


450°
    a disabled attribute
  
    default is false, its presence makes it true 
  
  
    <button disabled>Test Button</button>
  
    u cant get to the attribute like this however
  
    to control button state
  
    <input [disabled]="condition ? true : false">
    <input [attr.disabled]="condition ? 'disabled' : null">
  
    but use proppety binding in state management


360°
    Binding types and targets


property (element, component, or directive),
    <img [src]="heroImageUrl">
    <app-hero-detail [hero]="currentHero"></app-hero-detail>
    <div [ngClass]="{'special': isSpecial}"></div>

event (element, component, or directive),
    <button (click)="onSave()">Save</button>
    <app-hero-detail (deleteRequest)="deleteHero()"></app-hero-detail>
    <div (myClick)="clicked=$event" clickable>click me</div>


Two-way
    <input [(ngModel)]="name">

Attribute
    <button [attr.aria-label]="help">help</button>


Class
    <div [class.special]="isSpecial">Special</div>


Style
    <button [style.color]="isSpecial ? 'red' : 'green'">


    
270°
    Property binding [property]



360°
    One-way in
    property binding only allows for one way from a component to a target, no element property reading or method calling


    ex 
    
    to set element property to component property
    <img [src]="itemImageUrl">
  
    https://developer.mozilla.org/en-US/docs/Web/API/HTMLTableCellElement, have different names for attributes and properties

    disabled? to compoonent property
    <button [disabled]="isUnchanged">Disabled Button</button>


    setting the property of a directive
    <p [ngClass]="classes">[ngClass] binding to the classes property making this blue</p>

360°
    Binding Targets

    its done like this
    <img [src]="itemImageUrl">

    can also do this
    <img bind-src="itemImageUrl">


    from parent component to child component
    <app-item-detail [childItem]="parentItem"></app-item-detail>

    

    

  







  

    





    
    
    
    
    



90°
    Workspace npm dependencies

    all dependencies ar through npm
    
package.json
The package.json is organized into two groups of packages:

Dependencies are essential to running applications.
DevDependencies are only necessary to develop applications.

180°
    Dependencies
    Angular packages: Angular core and optional modules; their package names begin @angular/.
    
    Support packages: 3rd party libraries that must be present for Angular apps to run.
    
    Polyfill packages: Polyfills plug gaps in a browser's JavaScript implementation.
    
    to add a new dependency use ng add
    
270°
    DevDependencies
    packages that help you develop yr app you dont launch them on production
    to add a dependency npm install --dev <package-name>
    check em out
    

    
90°
    Testing
    

180°
    Setup
        Angular installs everything
        in angular-tour-of-heroes

    run ng test
    its builds the app in watch mode and launches karma test runner
    
    It seems I have to access it on my own computer

    https://karma-runner.github.io/4.0/config/configuration-file.html
    for my config use ChromeHeadless, and the listen address and host name to public so I can see it better
    and the app wants to take some files form [origin]/absolute/[root] so route your proxy to deal with URL approrpaites
    so that url redirects to the root of the OS FS

    if you look in all the componenet.spec.ts files you can see the testing software the jasmine is reporting and karma is running
    
90° CircleCI

180°
    Setup
    well will be using vendorly angular
    make the config.yml
    copy and paste
    
180°
    testing config file setup
    in karma.conf.js
    and make protractor-ci.conf.js which extends the original protractor.conf.js
    
        
90° Enable code coverage,

    this means that angular itself is working properly
    ng test --no-watch --code-coverage --browsers=ChromeHeadlessCI
    
    when you run this a folder called coverage is made in root it has an index.html for more details
    
    if you want code coverage everytime u test in angular.json
    
        "test": {
          "options": {
            "codeCoverage": true
          }
        }
        
180° Code coverage enforement
    
    if your team does not want to test everything u can set a percentage
    ex for 80%
    
    in karma.conf.js
    
        coverageIstanbulReporter: {
          reports: [ 'html', 'lcovonly' ],
          fixWebpackSourcePaths: true,
          thresholds: {
            statements: 80,
            lines: 80,
            branches: 80,
            functions: 80
          }
        }
            
    the code coverage enforcement is only 80%
    
90° Service Tests

angular says they are the easiest 2 test
refer to app/demo.service files


180° Services with dependencies

    refer  app/dependencyService

360°
    sometimes beforeEach does not reset the env when the step is too simple like setting a var to null
    also refer to the spy in the spec.ts to really understand how spies are used, createSpyObj is more like, generating your own function to follow
    spies are ususally the easiest way to mock services
    
    
180° TestBed and services
    as a service tester you must think about the constructor when mocking services, whether to make ur own or try to grab the actual  injected services. however Testbed takes care of order
    

90° Angular Testbed
    The TestBed is the most important of the Angular testing utilities. The TestBed creates a dynamically-constructed Angular test module that emulates an Angular @NgModule.
    
180° testing singular services
    refer app/testbedDep
    
    
180° testing dependencies
    
    its broken




180° not using before each
    
    function setup() {
      const valueServiceSpy =
        jasmine.createSpyObj('ValueService', ['getValue']);
      const stubValue = 'stub value';
      const masterService = new MasterService(valueServiceSpy);
    
      valueServiceSpy.getValue.and.returnValue(stubValue);
      return { masterService, stubValue, valueServiceSpy };
    }
    
dont set global vars in the body of the describe

in your spec

it('#getValue should return stubbed value from a spy', () => {
//
  const { masterService, stubValue, valueServiceSpy } = setup();
  //
  expect(masterService.getValue())
    .toBe(stubValue, 'service returned stub value');
  expect(valueServiceSpy.getValue.calls.count())
    .toBe(1, 'spy method was called once');
  expect(valueServiceSpy.getValue.calls.mostRecent().returnValue)
    .toBe(stubValue);
});

90° Testing HTTP services

make it ackts asynv because tht wht happens, but dont do this just make the XHR call


let httpClientSpy: { get: jasmine.Spy };
let heroService: HeroService;

beforeEach(() => {
  // TODO: spy on other methods too
  httpClientSpy = jasmine.createSpyObj('HttpClient', ['get']);
  heroService = new HeroService(<any> httpClientSpy);
});

it('should return expected heroes (HttpClient called once)', () => {
  const expectedHeroes: Hero[] =
    [{ id: 1, name: 'A' }, { id: 2, name: 'B' }];

  httpClientSpy.get.and.returnValue(asyncData(expectedHeroes));

  heroService.getHeroes().subscribe(
    heroes => expect(heroes).toEqual(expectedHeroes, 'expected heroes'),
    fail
  );
  expect(httpClientSpy.get.calls.count()).toBe(1, 'one call');
});

it('should return an error when the server returns a 404', () => {
  const errorResponse = new HttpErrorResponse({
    error: 'test 404 error',
    status: 404, statusText: 'Not Found'
  });

  httpClientSpy.get.and.returnValue(asyncError(errorResponse));

  heroService.getHeroes().subscribe(
    heroes => fail('expected an error, not heroes'),
    error  => expect(error.message).toContain('test 404 error')
  );
});


180°  HttpClientTestingModule

    actual XHR might be very difficults
    https://angular.io/guide/http#testing-http-requests
    


90° Component Test Basics

    a component is a html tempalte with a typescript class
    however you dont need Angular to load it in the DOM to properly test it , just look at the class
    angular testbed deals with this


180°  Component Class Testing

@Component({
  selector: 'lightswitch-comp',
  template: `
    <button (click)="clicked()">Click me!</button>
    <span>{{message}}</span>`
})
export class LightswitchComponent {
  isOn = false;
  clicked() { this.isOn = !this.isOn; }
  get message() { return `The light is ${this.isOn ? 'On' : 'Off'}`; }
}


to test it get an instance and play with it

describe('LightswitchComp', () => {
  it('#clicked() should toggle #isOn', () => {
    const comp = new LightswitchComponent();
    expect(comp.isOn).toBe(false, 'off at first');
    comp.clicked();
    expect(comp.isOn).toBe(true, 'on after click');
    comp.clicked();
    expect(comp.isOn).toBe(false, 'off after second click');
  });
 })
 

to test some functionality

we gotta make our own test



180°  Components with dependencies
    look at welcome component
    
    so basically the service and the component both need to be inside spec, you can activate the lifecycle hook by simple calling the fn lol
    
    
180°  Component DOM testing
    
    class only tests cannot
        tell you if the component is going to render properly,
        respond to user input and gestures,
        or integrate with its parent and child components.
        
    to simulate DOM interaction use TestBed interactions
    
    
270°  CLI-generated tests

    focus on banner component
    generate a compoent like this
    
    so in the testing file, everything but the actual spec creates and sets up for Mock DOM
    
 
360° Reduce the setup

    make it look like the sectiong between
    
    so here
    
    TestBed.configureTestingModule({
      declarations: [ BannerComponent ]
    });
    testBed sees we need the testingComponent
    
    and from there thats it, there are other modules that know what to do
    

360° createComponent()

    after that tiny config you call its createComponent()
        creates instance
        adds the element to test-runner DOM,
        returns a component Fixture
        
    do not reconfigure TestBed after calling this
    the definition is frozen after the invocation
    do not call any TestBed conf such as configureTestingModule(), nor get(), nor any of the override... methods. or u get an error
    const fixture = TestBed.createComponent(BannerComponent);
    
360° ComponentFixture()

    its how u interact with the element as a DOM
    to confirm it exists with jasmine
            
        const component = fixture.componentInstance;
        expect(component).toBeDefined()
            
360° beforeEach()
    then at this point place all your jasmine tests in specs

    
360° nativeElement

    its has the type of any type also DebugElement.nativeElement has the fixture of any type
    at compile tile this might be a WebWorker or some server side when the respective class is diminished
    however the tests here always run in a browser environment so <any> means HTMLElement
    so you can use querySelector
    
    
360° debugElement
    
    we have
    const bannerDe: DebugElement = fixture.debugElement;
    const bannerEl: HTMLElement = bannerDe.nativeElement;
    
    this element is used for global support, it returns platform specific
    
    you need to grab it from @angular/core
    
360° By.css()

    some apps might run on a different platform and u dont get the full Element API
     debugElement has its own querySelector protocol
     it methods that take predicates and returns node when theres a match
    heres how to make a  predicate
    
    import { By } from '@angular/platform-browser';
    
    it('should find the <p> with fixture.debugElement.query(By.css)', () => {
      const bannerDe: DebugElement = fixture.debugElement;
      const paragraphDe = bannerDe.query(By.css('p'));
      const p: HTMLElement = paragraphDe.nativeElement;
      expect(p.textContent).toEqual('banner works!');
    });
        

    so whats happening
    
        The By.css() static method selects DebugElement nodes with a standard CSS selector.
        The query returns a DebugElement for the paragraph.
        You must unwrap that result to get the paragraph element.
        
    use this method over querySelector its overkill
    


180° Component Test Scenarios
    
  
270° Component binding

@Component({
  selector: 'app-banner',
  template: '<h1>{{title}}</h1>',
  styles: ['h1 { color: green; font-size: 350%}']
})
export class BannerComponent {
  title = 'Test Tour of Heroes';
}
    
so we need to find out if title ends up in the interploation



let component: BannerComponent;
let fixture:   ComponentFixture<BannerComponent>;
let h1:        HTMLElement;

beforeEach(() => {
  TestBed.configureTestingModule({
    declarations: [ BannerComponent ],
  });
  fixture = TestBed.createComponent(BannerComponent);
  component = fixture.componentInstance; // BannerComponent test instance
  h1 = fixture.nativeElement.querySelector('h1');
 
});

360° detectChanges()

at this point you need change dectection for the interpolation bind to occur
you must tell TestBed to detect changes, good so you can inspect things before the change


it('should display original title after detectChanges()', () => {
  fixture.detectChanges();
  expect(h1.textContent).toContain(component.title);
});


it('should display a different test title', () => {
  component.title = 'Test Title';
  fixture.detectChanges();
  expect(h1.textContent).toContain('Test Title');
});

360°  Change an input value with dispatchEvent()

angular testing is not too good at detecting changes
to simulate user input
  // simulate user entering a new name into the input box
  nameInput.value = 'quick BROWN  fOx';

  // dispatch a DOM event so that Angular learns of input value change.
  nameInput.dispatchEvent(newEvent('input'));

  // Tell Angular to update the display binding through the title pipe
  fixture.detectChanges();
  
  
270° Component with external files

    so in inline they way to access the html and css is
    
    @Component.template and @Component.styles properties respectively, as the following variant of BannerComponent does.
    
    so in extenal how u access is
    
    @Component.templateUrl and @Component.styleUrls properties respectively, as the following variant of BannerComponent does.
    
    inside the cli its not a problem
    
    in plunker ull get this
    
    Error: This test module uses the component BannerComponent
    which is using a "templateUrl" or "styleUrls", but they were never compiled.
    Please call "TestBed.compileComponents" before your test.
    
    
270° Calling compileComponents()

    TestBed.createComponent() is called and there are extenral files, they are being read in async
    
    call it in an async fn like this
    
    
    import { async, ComponentFixture, TestBed } from '@angular/core/testing';
    
        beforeEach(async(() => {
          TestBed.configureTestingModule({
            declarations: [ BannerComponent ],
          })
          .compileComponents();  // compile template and css
        }));
            
          
        Make compileComponents() the last step before calling TestBed.createComponent().
        Dont reconfigure testBed after calling compileComponents()
        
360° The synchronous beforeEach()



    beforeEach(() => {
      fixture = TestBed.createComponent(BannerComponent);
      component = fixture.componentInstance; // BannerComponent test instance
      h1 = fixture.nativeElement.querySelector('h1');
    });
            
      
   or do this all with a promise



83
to add multiple template bindings
You can use the <ng-container> helper element for that.

<ng-container *ngFor="let item of headerItems" >
 <td *ngIf="item.visible">{{ item?.name }}</td>
</ng-container>
It is not added to the DOM.
        
    
    


    
    