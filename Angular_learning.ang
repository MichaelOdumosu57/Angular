

template
90° 90°


90° update yr angular project90°
https://medium.com/panya-studio-engineering/angular-cli-update-issues-manually-update-your-angular-project-ba0b1ea1c727

90° Learning Angular 90°

to set up a reverse proxy look at the location /a in that default.conf file its real easy all you need really is the proxy pass
also you need https://medium.com/@icanhazstring/how-to-properly-get-angular-and-nginx-working-together-for-development-3e5d158734bf
so it can rebuild properly

for a free angular host
https://stackblitz.com/




90° Getting Started 90°

run
ng new my-app
accept defaults with accept and return key

cd my-app
ng serve
--open opens the app in your defualt browser
its running

180° editing components 180°
in src/app/app.component.ts
change title to My First Angular App

the css is like regular HTML programming added it to apply  a style


90° Tour of Heroes 90°

270°Angular is made of Components there are modular versios of React but simpler
    the class file is the .ts
    the template file is the .html

270°  replace this with anything you want
      <h1>{{title}}</h1>
      it related to the class file
      so the template puts on the class file like clothes

270°
    src/ is like a global that all components must use
    especially in src styles

270°
    to make a new component
    ng generate component [name of component]
    
360°
    @Component is a decorator function
        selector - the component's CSS element selector
        templateUrl— the location of the component's template file.
        styleUrls— the location of the component's private CSS styles.
        ngOnInit  is a lifecycle hook
        always export the component class
        
270°
    to add a a value for non app
    {{[value]}} with no
    this put between HTML tags is known as interpolation binding
    
270°
    to display a component add it to template for the AppComponet
    insert it
    <h1>{{title}}</h1>
    <app-heroes></app-heroes>

270°
    now we create a hero class
    youre basically importing a class in the example

270°
    now to properly show it
    <h2>{{hero.name | uppercase}} Details</h2>
    <div><span>id: </span>{{hero.id}}</div>
    <div><span>name: </span>{{hero.name}}</div>
    
    which lives in <app-heroes></app-heroes> amazing
    
270°
    users can edit it
    <input [(ngModel)]="hero.name" placeholder="name"/>
    where ngModel binds that
    
180°
    AppModule
    not everything is availbe by default
    this is in app.module.ts and they come as @NgModule decorators
    so you import it in app.module.ts
    import { FormsModule } from '@angular/forms';
    and you add it to the @NgModule decorrator, imports array
    
270°
    every component must be declared in exactly on NgModule declaration
    file:/app/app.module.ts
    
180°
<!--4-->
    A list of Heroes
    this is where typescript is noticeable
    
    files
    /src/app/mock-heroes.ts
    /src/app/heroes/heroes.component.ts
    
    to list use *ngFor
    /src/app/heroes.component.html
    
    never forget the asterick

270°
    event binding
<!--5-->
    files: /heroes.component.ts
        :heroes.component.html
    <li *ngFor="let hero of heroes" (click)="onSelect(hero)">
    

270°
<!--6-->
    however selectedHero does not exist
    use *ngIf to save the app
    files:heroes.component.html
    

270°
    <!--7-->
    stlying specific components in its list
    this is done with class binding
    [class.[className]]="hero === selectedHero"
    files:heroes.component.html
        
180°
    <!--8-->
    you want larger apps to maintain smaller ones
    so there are different component we have differnt ways to attach things
    property biding is present in the subComponent and the @Input decorator is needed to function properly
    files
    files:hero-detail.component.ts
        :hero-detail.component.html
        :heroes.component.html
        

180°
    <!--9-->
    you want services
        they rely on this dependecy injection system
    to do this
    ng generate service hero
    files:hero.service.ts
    files:hero.service.spec.ts
    
    it has a @Injectable decorator
    
270°
    <!--9-->
    this hero service component can grab data from anywhere
    
    you must make this availble to the dependecy injection system (DIS) by regeristing a provider
    provider creates or delivers a services
    HeroService must be registered as the provider of the service you set up an injector which is repsoible for putting
    the service in the right place
    in the Injectable decorator when its provided in the root it can remove it if its not needed
    
270°
    <!--10-->
    instrsting things happen a singleton instance
    now a service is running in your app
    file:heroes.component.ts
    
270°
    <!--11-->
    call the service
    is should be called in ngOnInit not in the constructor, the constructor shouldnt do anything
    so services need to be injected and special care must be taken
    
180°
     <!--12-->
    the service operates sync, but in a real world app we need this done in async, you can use a callback Promise or an Observable
    they are from the RxJS library
    fn returns an Observable<Hero[]> that emits a single value, the array of mock heroes.
    Observable.suscribe() is the async solution here
    files: hero.service.ts
           heroes.component.ts

180°
    <!--13-->
    Showing messages
    bascially executes that the service went through properly
    files:app.component.html
        /src/app/message.service.ts
        /src/app/messages/messages.component.ts
           
    
180°
    <!--14-->
    App routing
    in Angular, the best practice is to load and configure the router in a separate, top-level module that is dedicated to routing and imported by the root AppModule.
--flat puts the file in src/app instead of its own folder.
--module=app tells the CLI to register it in the imports array of the AppModule.
    files: /src/app/app-routing.module.ts
    
270°
    <!--15-->
    Routes
        when you navigate to localhost:4200/heroes you get the HeroesComponent its the same with  nginx routing
        You first must initialize the router and start it listening for browser location changes.
        I removes the Heroes-Component because you only want it when the user navigates to it
        you can make things work by moving codeblocks around
    files:app-routing.module.ts
        files:/src/app/app.component.html
        

180°
    <!--16-->
    Navigation
    add a nav and anchor element
    file:/src/app/app.component.html
    
180°
    <!--17-->
    Add a dashboard
    ng generate component dashboard
    folder /src/app/dashboard
        /src/app/app-routing.module.ts
    
270°
    <!--18-->
    Add a default route
    files: /src/app/app-routing.module.ts
            /src/app/app.component.html
                
270°
    <!--19-->
    add a hero detail route that hides that hero list from the heroes compoinet
    use : for routing parameters
    using interpolation binding to properly connect things
    tie the Heroes Component and Details Component together
    files:/src/app/app-routing.module.ts
        /src/app/dashbord/dashbord.component.html
        
270°
    <!--20-->
    Routable HeroDetailComponent
    now heroe detail needs a way to grab that from the routing and ask the service from HeroService and grab the data it needs from the server
    ActivatedRoute has info about the route
    files:/src/app/hero-detail/hero-detail.component.ts
    
270°
    <!--21-->
    if you go back in the browser you can move around in the app
    files:/src/app/hero-detail/hero-detail.component.ts
          /src/app/hero-detail/hero-detail.component.html
          
180°
    <!--22-->
    using Angular's HttpClient.
    communciate with remote server over http
    for express try to send what the ts fnd demands
        An observable from HttpClient always emits a single value AND thats it
        it can doe it mulitple times however
    HttpClient.get returns the body of the response as an untyped JSON object by default.
    file:/src/app/app.module.ts
    /AngularBackend/template_app.js
    
270°
    <!--23-->
    Error handling
    pipe result through RxJS catchError() operator.
    you can do what you want there
    file:/src/app/hero.service.ts
    
270°
    <!--24-->
    Tap into the observable
    passes them along to whoever needs it
    you can also go ahead and save it tell your backend to do this
    The HttpClient.put() method takes three parameters
    
        the URL
        the data to update (the modified hero in this case)
        options - consist of the header to send in the request
    

    file:/src/app/hero.service.ts
        /src/app/hero-detail.component.html
        /src/app/hero-detail.component.ts
        /AngularBackend/template_app.js
        /src/app/heroes.component.html
        /src/app/heroes.component.ts
    
270°
    <!--25-->
    so add the button to do it
    
    file: /src/app/heroes.component.html
          /src/app/heroes.component.ts
          /src/hero.service.ts
          /template_app.js
          
270°
    <!--26-->
    lets delete heroes
    
        files:/src/app/heroes.component.html
          /src/app/heroes.component.ts
          /src/hero.service.ts
          /template_app.js
          
270°
    <!--27-->
    a search of services
    ng generate component hero-search
    files:hero.service.ts
        dashboard.component.html
        hero-search.component.html
        
270°
    <!--28-->
    // <li *ngFor="let hero of heroes$ | async"" |" >
    $ shows heroes is an Observable
    seems like you have to declare it in its class file
    the async suscribes so you dont have to try
        files: hero-search.component.html
                 hero-search.component.ts
                 
270°
    <!--29-->
    A Subject is both a source of observable values and an Observable itself.
    you can suscribe
    you can push values using next method
    this is useful for something
    file:hero-detail.component
    


90°
    Testing

180°
    Setup
        Angular installs everything
        in angular-tour-of-heroes

    run ng test
    its builds the app in watch mode and launches karma test runner
    
    It seems I have to access it on my own computer

    https://karma-runner.github.io/4.0/config/configuration-file.html
    for my config use ChromeHeadless, and the listen address and host name to public so I can see it better
    and the app wants to take some files form [origin]/absolute/[root] so route your proxy to deal with URL approrpaites
    so that url redirects to the root of the OS FS

    if you look in all the componenet.spec.ts files you can see the testing software the jasmine is reporting and karma is running
    
90° CircleCI

180°
    Setup
    well will be using vendorly angular
    make the config.yml
    copy and paste
    
180°
    testing config file setup
    in karma.conf.js
    and make protractor-ci.conf.js which extends the original protractor.conf.js
    
        
90° Enable code coverage,

    this means that angular itself is working properly
    ng test --no-watch --code-coverage --browsers=ChromeHeadlessCI
    
    when you run this a folder called coverage is made in root it has an index.html for more details
    
    if you want code coverage everytime u test in angular.json
    
        "test": {
          "options": {
            "codeCoverage": true
          }
        }
        
180° Code coverage enforement
    
    if your team does not want to test everything u can set a percentage
    ex for 80%
    
    in karma.conf.js
    
        coverageIstanbulReporter: {
          reports: [ 'html', 'lcovonly' ],
          fixWebpackSourcePaths: true,
          thresholds: {
            statements: 80,
            lines: 80,
            branches: 80,
            functions: 80
          }
        }
            
    the code coverage enforcement is only 80%
    
90° Service Tests

angular says they are the easiest 2 test
refer to app/demo.service files


180° Services with dependencies

    refer  app/dependencyService

360°
    sometimes beforeEach does not reset the env when the step is too simple like setting a var to null
    also refer to the spy in the spec.ts to really understand how spies are used, createSpyObj is more like, generating your own function to follow
    spies are ususally the easiest way to mock services
    
    
180° TestBed and services
    as a service tester you must think about the constructor when mocking services, whether to make ur own or try to grab the actual  injected services. however Testbed takes care of order
    

90° Angular Testbed
    The TestBed is the most important of the Angular testing utilities. The TestBed creates a dynamically-constructed Angular test module that emulates an Angular @NgModule.
    
180° testing singular services
    refer app/testbedDep
    
    
180° testing dependencies
    
    its broken




180° not using before each
    
    function setup() {
      const valueServiceSpy =
        jasmine.createSpyObj('ValueService', ['getValue']);
      const stubValue = 'stub value';
      const masterService = new MasterService(valueServiceSpy);
    
      valueServiceSpy.getValue.and.returnValue(stubValue);
      return { masterService, stubValue, valueServiceSpy };
    }
    
dont set global vars in the body of the describe

in your spec

it('#getValue should return stubbed value from a spy', () => {
//
  const { masterService, stubValue, valueServiceSpy } = setup();
  //
  expect(masterService.getValue())
    .toBe(stubValue, 'service returned stub value');
  expect(valueServiceSpy.getValue.calls.count())
    .toBe(1, 'spy method was called once');
  expect(valueServiceSpy.getValue.calls.mostRecent().returnValue)
    .toBe(stubValue);
});

90° Testing HTTP services

make it ackts asynv because tht wht happens, but dont do this just make the XHR call


let httpClientSpy: { get: jasmine.Spy };
let heroService: HeroService;

beforeEach(() => {
  // TODO: spy on other methods too
  httpClientSpy = jasmine.createSpyObj('HttpClient', ['get']);
  heroService = new HeroService(<any> httpClientSpy);
});

it('should return expected heroes (HttpClient called once)', () => {
  const expectedHeroes: Hero[] =
    [{ id: 1, name: 'A' }, { id: 2, name: 'B' }];

  httpClientSpy.get.and.returnValue(asyncData(expectedHeroes));

  heroService.getHeroes().subscribe(
    heroes => expect(heroes).toEqual(expectedHeroes, 'expected heroes'),
    fail
  );
  expect(httpClientSpy.get.calls.count()).toBe(1, 'one call');
});

it('should return an error when the server returns a 404', () => {
  const errorResponse = new HttpErrorResponse({
    error: 'test 404 error',
    status: 404, statusText: 'Not Found'
  });

  httpClientSpy.get.and.returnValue(asyncError(errorResponse));

  heroService.getHeroes().subscribe(
    heroes => fail('expected an error, not heroes'),
    error  => expect(error.message).toContain('test 404 error')
  );
});


180°  HttpClientTestingModule

    actual XHR might be very difficults
    https://angular.io/guide/http#testing-http-requests
    


90° Component Test Basics

    a component is a html tempalte with a typescript class
    however you dont need Angular to load it in the DOM to properly test it , just look at the class
    angular testbed deals with this


180°  Component Class Testing

@Component({
  selector: 'lightswitch-comp',
  template: `
    <button (click)="clicked()">Click me!</button>
    <span>{{message}}</span>`
})
export class LightswitchComponent {
  isOn = false;
  clicked() { this.isOn = !this.isOn; }
  get message() { return `The light is ${this.isOn ? 'On' : 'Off'}`; }
}


to test it get an instance and play with it

describe('LightswitchComp', () => {
  it('#clicked() should toggle #isOn', () => {
    const comp = new LightswitchComponent();
    expect(comp.isOn).toBe(false, 'off at first');
    comp.clicked();
    expect(comp.isOn).toBe(true, 'on after click');
    comp.clicked();
    expect(comp.isOn).toBe(false, 'off after second click');
  });
 })
 

to test some functionality

we gotta make our own test



180°  Components with dependencies
    look at welcome component
    
    so basically the service and the component both need to be inside spec, you can activate the lifecycle hook by simple calling the fn lol
    
    
180°  Component DOM testing
    
    class only tests cannot
        tell you if the component is going to render properly,
        respond to user input and gestures,
        or integrate with its parent and child components.
        
    to simulate DOM interaction use TestBed interactions
    
    
270°  CLI-generated tests

    focus on banner component
    generate a compoent like this
    
    so in the testing file, everything but the actual spec creates and sets up for Mock DOM
    
 
360° Reduce the setup

    make it look like the sectiong between
    
    so here
    
    TestBed.configureTestingModule({
      declarations: [ BannerComponent ]
    });
    testBed sees we need the testingComponent
    
    and from there thats it, there are other modules that know what to do
    

360° createComponent()

    after that tiny config you call its createComponent()
        creates instance
        adds the element to test-runner DOM,
        returns a component Fixture
        
    do not reconfigure TestBed after calling this
    the definition is frozen after the invocation
    do not call any TestBed conf such as configureTestingModule(), nor get(), nor any of the override... methods. or u get an error
    const fixture = TestBed.createComponent(BannerComponent);
    
360° ComponentFixture()

    its how u interact with the element as a DOM
    to confirm it exists with jasmine
            
        const component = fixture.componentInstance;
        expect(component).toBeDefined()
            
360° beforeEach()
    then at this point place all your jasmine tests in specs

    
    
    
        
    
    


    
    